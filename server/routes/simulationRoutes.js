const express = require('express');
const router = express.Router();
const SimulationEngine = require('../modules/simulationEngine');
const BacktestingEngine = require('../modules/backtestingEngine');
const AIAgentChain = require('../modules/aiAgentChain');
const { apiLimiter } = require('../middleware/rateLimit');

// Initialize engines
const simulationEngine = new SimulationEngine();
const backtestingEngine = new BacktestingEngine();
const aiChain = new AIAgentChain();

// Simulation routes

/**
 * Start simulation mode
 */
router.post('/start', apiLimiter, (req, res) => {
  try {
    const result = simulationEngine.startSimulation();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Stop simulation mode
 */
router.post('/stop', apiLimiter, (req, res) => {
  try {
    const result = simulationEngine.stopSimulation();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Reset simulation to initial state
 */
router.post('/reset', apiLimiter, (req, res) => {
  try {
    const result = simulationEngine.resetSimulation();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get current simulation portfolio status
 */
router.get('/portfolio', (req, res) => {
  try {
    const status = simulationEngine.getPortfolioStatus();
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get simulation performance report
 */
router.get('/performance', (req, res) => {
  try {
    const report = simulationEngine.getPerformanceReport();
    res.json(report);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get simulation trade history
 */
router.get('/trades', (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const trades = simulationEngine.getTradeHistory(limit);
    res.json({ trades });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Execute AI-recommended trade in simulation
 */
router.post('/execute-ai-trade', apiLimiter, async (req, res) => {
  try {
    const { symbol, marketContext, accountBalance } = req.body;

    // Validate inputs
    if (!symbol) {
      return res.status(400).json({ error: 'Symbol is required' });
    }

    if (!marketContext) {
      return res.status(400).json({ error: 'MarketContext is required' });
    }

    // Check if AI services are configured
    if (!aiChain.isConfigured()) {
      return res.status(503).json({
        error: 'AI services not configured. Please check API keys for Gemini and Cohere.'
      });
    }

    // Check if simulation is active
    if (!simulationEngine.portfolio.isActive) {
      return res.status(400).json({ error: 'Simulation not active. Start simulation first.' });
    }

    console.log(`Simulation: Processing AI trade for ${symbol}`);

    // Execute AI chain
    const aiResult = await aiChain.executeChain(marketContext, accountBalance || simulationEngine.getPortfolioStatus());

    if (!aiResult.executableTrade) {
      return res.status(400).json({ error: 'No executable trade generated by AI chain' });
    }

    // Execute trade in simulation
    const tradeResult = simulationEngine.executeTrade(aiResult.executableTrade);

    res.json({
      success: true,
      symbol,
      aiResult,
      simulationResult: tradeResult
    });

  } catch (error) {
    console.error('Simulation AI trade error:', error);

    // Handle rate limiting
    if (error.message.includes('Rate limit exceeded')) {
      return res.status(429).json({
        error: 'AI API rate limit exceeded. Please try again later.',
        retryAfter: 60
      });
    }

    res.status(500).json({
      error: 'Failed to execute AI trade in simulation',
      details: error.message
    });
  }
});

/**
 * Manually execute a trade in simulation
 */
router.post('/execute-manual-trade', apiLimiter, (req, res) => {
  try {
    const { trade } = req.body;

    if (!trade) {
      return res.status(400).json({ error: 'Trade object is required' });
    }

    if (!simulationEngine.portfolio.isActive) {
      return res.status(400).json({ error: 'Simulation not active. Start simulation first.' });
    }

    const result = simulationEngine.executeTrade(trade);
    res.json(result);

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Close a position in simulation
 */
router.post('/close-position', apiLimiter, (req, res) => {
  try {
    const { positionKey, exitPrice } = req.body;

    if (!positionKey || !exitPrice) {
      return res.status(400).json({ error: 'Position key and exit price are required' });
    }

    const result = simulationEngine.closePosition(positionKey, parseFloat(exitPrice));
    res.json(result);

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Backtesting routes

/**
 * Start backtest
 */
router.post('/backtest/start', apiLimiter, async (req, res) => {
  try {
    const {
      assets = ['bitcoin', 'ethereum'],
      days = 30,
      speed = 1,
      initialBalance = 10000
    } = req.body;

    // Validate inputs
    if (!Array.isArray(assets) || assets.length === 0) {
      return res.status(400).json({ error: 'Assets must be a non-empty array' });
    }

    if (days < 1 || days > 365) {
      return res.status(400).json({ error: 'Days must be between 1 and 365' });
    }

    console.log(`Starting backtest: ${assets.join(', ')} for ${days} days at speed ${speed}x`);

    // Start backtest asynchronously
    backtestingEngine.runBacktest({ assets, days, speed, initialBalance })
      .then(result => {
        console.log('Backtest completed successfully');
      })
      .catch(error => {
        console.error('Backtest failed:', error);
      });

    res.json({
      success: true,
      message: 'Backtest started',
      parameters: { assets, days, speed, initialBalance }
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Stop running backtest
 */
router.post('/backtest/stop', (req, res) => {
  try {
    backtestingEngine.stopBacktest();
    res.json({ success: true, message: 'Backtest stopped' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get backtest status
 */
router.get('/backtest/status', (req, res) => {
  try {
    const status = backtestingEngine.getStatus();
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get backtest results
 */
router.get('/backtest/results', (req, res) => {
  try {
    const results = backtestingEngine.getResults();
    res.json(results);
  } catch (error) {
    if (error.message === 'No backtest results available') {
      return res.status(404).json({ error: error.message });
    }
    res.status(500).json({ error: error.message });
  }
});

/**
 * Get available backtest assets
 */
router.get('/backtest/assets', (req, res) => {
  res.json({
    availableAssets: [
      { id: 'bitcoin', name: 'Bitcoin', symbol: 'BTC' },
      { id: 'ethereum', name: 'Ethereum', symbol: 'ETH' }
    ],
    defaultAssets: ['bitcoin', 'ethereum']
  });
});

/**
 * Get backtest configuration options
 */
router.get('/backtest/config', (req, res) => {
  res.json({
    defaultConfig: {
      assets: ['bitcoin', 'ethereum'],
      days: 30,
      speed: 1,
      initialBalance: 10000
    },
    limits: {
      maxDays: 365,
      minDays: 1,
      maxSpeed: 10,
      minSpeed: 0.1,
      maxAssets: 5
    }
  });
});

module.exports = router;